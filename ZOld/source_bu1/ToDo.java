/* ToDo
 * ====
 * CachedGlyph also contains byte array - for Mem.Img.Src. applications...
 *   This is the most fundamental bit, actually - calculate it first...
 *    CachedGlyph also contains: colours textures, etc...
 * String measurement - i.e. FontMetrics...!
 *   Given a line of text - and a length - say how many characters fit...
 * Speedup for glyph top (this looks like a lot of work)...
 * Type-and-see Demonstration app features:
 *  Demo text needs to go on multiple lines...
 *  Demo text needs moving down...
 *  Allow configurable text colour...?
 *  Foreground Texture...?
 *  Use GridBag...?
 *  Permit background texture - and build in texture blending...
 *  Shadow...
 * Pen...
 *  Diamond-shaped pen...
 *  Pen for drawing shadow with...
 * Disable (non-trivial) hinting using conditional-compilation...?
 * Make an effort to stop doing everything twice for X and Y (mostly done)...
 * Only one frame per glyph allowed (use array of frames to make sure)...
 * Only one "type-and-see" demonstration app allowed...?
 * Hint inner edges of outlines - if necessary...?
 * HintX and HintY...
 *  Don't h-hint italic fonts...
 * Hint quality levels...
 * Investigate specific hinting problems:
 *  Hinting of Lucky's "#"...
 *  Hinting of Lucky's "t", "f"...
 *  Hinting of Lucky's "H" when rather small...
 *  Look into how the central stem of Lucky's "m" is hinted...
 *  Hinting of Typeright's "4"..
 * Make robust in the face of corrupt fonts...
 *  ErazerDust + KidTypePaint - 100% CPU...
 * Optimise more for power-of-2 qualities - to avoid doing division...
 * Button to map points to instructions...
 * InstructionStream: fepointlist and could be cached per GDO... 
 * "Lucida Sans" - if only one path, it must be black...
 *   Reverse path on glyphs that need it...
 * Optimise: Don't use hashtable if last used... ;-)
 * Optimise:Once you have calculated the springs, don't forget about them...
 * Optimise:Once you have calculated the pre-hinted points, don't forget about them...
 * Optimise: Cache (and invalidate) the hash code - to speed up equals() in GDO and Coords...
 * Use the FontRenderer and Glyph cache in the editor...???
 * Think about weak references to the fonts...?
 * Make FEFont effectively immutable (at least in the renderer)...
 * Thread to expire items from cache...
 * TTHashtable code.  Hashtable won't work with MIDP due to use of "float"...
 * Hinting...
 *  *Should* pay attention to the baseline...
 *  Springs...
 *   Use springs for hinting...
 *   Improve heuristics for spring creation:
 *    Find the spring at the tail of LC's "Q"...
 *   Springs between sliders...
 *  Detect and exploit glyph symmetry (where present)...!? ;-)
 *  Extra type of slider (cusp)...?
 *  Extra type of slider (straight line)...?
 * Demonstration apps...
 *  Flames/wobble...
 *  Type and see...
 *  Text area...
 *  Scrolltext...
 *  Text editor...
 *  Haiku maker...
 *  Use in Rockz...
 * Build Java GUI - using these fonts...
 * FEPointLinked class...?
 * Allow loading of bitmap fonts...?
 * Editor:
 *  Should not be able to select things that are not visible...
 *  Show coordinates of a point whenever it is selected...
 *  Allow coordinates of points to be  modified in the same way...
 *  "Resize selection"...
 *  Ctrl key action...
 *  Increase grid width - if too narrow for display...?
 *  Alter depth...
 *  Delete path...
 *  New path...
 *  Reverse path...
 *  Copy/Paste (clone)...
 *  Undo/redo...
 *  Add points to existing lines...
 *  Resize glyph (X / Y) - drag corners...
 *  It should be easier to select points...
 *  Keyboard - delete, etc...
 *  Delete curves...
 *  Delete stroke...
 *  New stroke...
 *  Smart "Snap to grid" functionality while dragging...
 *  Only redraw what's necessary... ;-)
 *  Points in uppermost paths should be "on top" (selection problems otherwise)...
 *  Check "upper" points first when selecting...
 * Compound glyphs...
 * Auto-generate hinting instructions...???
 * (Optionally) Center glyphs...??
 * Pretty-looking UI...??
 * Reuse existing TTImage when anti-aliasing...???
 * Optimise: Only draw circle at *one* end of thick lines...
 * Optionally - use a square as a think line end...
 * Optionally - use a diagonal line to draw with (for shadows)...
 * Selection type: letter/curve/point(s)
 * Painting onto textured backgrounds...
 * Visible framework - three boxes...
 * ...leading to: square selection indicator - with "resize" corners...
 * Show highlighted curve...?????
 * Finish TrueType ripper application...
 * *Eventually* eliminate InstructionStream class - in streamlined runtime...?
 * TrueType:
 *  Is direct TT rendering a possibility?
 *  Directly parse TT files...
 */
